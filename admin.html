<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Administração - Gerenciamento de Cards</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/public/styles.css">
    <style>
        /* Estilos específicos para a página de administração */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow-y: scroll;
        }

        .admin-container {
            max-width: 900px;
            margin: 40px auto;
            padding: 25px;
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .admin-container h1 {
            font-size: 1.8rem;
            color: #334155;
            text-align: center;
            margin-bottom: 15px;
        }

        .section-header {
            font-size: 1.4rem;
            color: #334155;
            text-align: center;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e2e8f0;
        }

        /* --- Estilos do Menu de Opções --- */
        .admin-menu {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f8fafc;
            border-radius: 10px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }

        .menu-item {
            padding: 10px 15px;
            border-radius: 8px;
            background-color: #e2e8f0;
            color: #475569;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
            white-space: nowrap; /* Impede quebras de linha */
        }

        .menu-item:hover {
            background-color: #cbd5e1;
            color: #1e293b;
        }

        .menu-item.active {
            background-color: #4f46e5;
            color: white;
            box-shadow: 0 2px 6px rgba(79, 70, 229, 0.3);
        }

        .menu-item.active:hover {
            background-color: #3730a3;
        }

        /* --- Conteúdo das Seções (inicialmente oculto) --- */
        .admin-section-content {
            display: none; /* Por padrão, todas as seções de conteúdo estão ocultas */
            padding: 15px;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            background-color: #fdfdfd;
        }

        .admin-section-content.active {
            display: flex; /* Apenas a seção ativa é exibida */
            flex-direction: column;
            gap: 15px;
        }
        /* --- Fim Estilos do Menu --- */


        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #475569;
        }

        .form-group textarea,
        .form-group input[type="text"],
        .form-group input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        .form-group input[type="password"] {
            font-family: monospace;
        }


        .form-group textarea {
            height: 300px;
            font-family: monospace;
        }

        .action-button {
            background-color: #4CAF50; /* Verde */
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
            width: 100%;
            border: none;
            margin-top: 10px;
        }

        .action-button.generate {
            background-color: #007ACC; /* Azul para gerar via IA */
        }

        .action-button.csv-upload { 
            background-color: #27AE60; 
        }

        .action-button.refresh-all { 
            background-color: #3498db; 
        }

        .action-button.search-single { /* NOVO: Estilo para o botão de buscar card único */
            background-color: #FF8C00; /* Laranja escuro */
        }
        .action-button.update-single { /* NOVO: Estilo para o botão de atualizar card único */
            background-color: #FFD700; /* Dourado */
            color: #333; /* Cor de texto para contraste com dourado */
        }
        .action-button.update-single:hover {
            background-color: #FFC400;
        }


        .action-button:hover {
            background-color: #45a049;
        }

        .action-button.generate:hover {
            background-color: #005B99;
        }

        .action-button.csv-upload:hover { 
            background-color: #1E8449; 
        }

        .action-button.refresh-all:hover { 
            background-color: #2980b9;
        }

        .action-button.search-single:hover { /* Hover para buscar card único */
            background-color: #E67E00;
        }


        .action-button:disabled {
            background-color: #a5d6a7;
            cursor: not-allowed;
            box-shadow: none;
        }
        .action-button.generate:disabled {
            background-color: #8ac0e2;
            cursor: not-allowed;
        }
        .action-button.csv-upload:disabled { 
            background-color: #82E0AA;
            cursor: not-allowed;
        }
        .action-button.refresh-all:disabled { 
            background-color: #8ac0e2;
            cursor: not-allowed;
        }
        .action-button.search-single:disabled { /* Disabled para buscar card único */
            background-color: #FFB366;
            cursor: not-allowed;
        }
        .action-button.update-single:disabled { /* Disabled para atualizar card único */
            background-color: #FFF0B3;
            cursor: not-allowed;
        }


        .admin-message-area {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
            text-align: center;
            min-height: 20px;
        }

        .admin-message-area.info {
            background-color: #e0f2f7;
            color: #01579b;
        }
        .admin-message-area.success {
            background-color: #e8f5e9;
            color: #2e7d32;
        }
        .admin-message-area.error {
            background-color: #ffebee;
            color: #c62828;
        }
        .admin-message-area.warning {
            background-color: #fff3e0;
            color: #e65100;
        }

        /* Estilo para exibir o card buscado no admin */
        .single-card-display-admin {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px; /* Garante espaço para o card */
            margin-top: 20px;
            background-color: #e2e8f0; /* Fundo para destacar */
            border-radius: 15px;
            padding: 20px;
        }
        .single-card-display-admin .card-container {
            margin: 0; /* Remove margem extra se o card-container tiver */
        }


        .back-to-home-button {
            background-color: #7f8c8d;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
            border: none;
            text-align: center;
            margin-top: 20px; 
            width: 100%;
        }

        .back-to-home-button:hover {
            background-color: #5c6a6b;
        }

        @media (max-width: 768px) {
            .admin-container {
                margin: 20px auto;
                padding: 15px;
            }
            .admin-container h1 {
                font-size: 1.5rem;
            }
            .section-header {
                font-size: 1.2rem;
                margin-top: 20px;
            }
            .form-group textarea,
            .form-group input {
                padding: 8px;
            }
            .action-button {
                padding: 10px 15px;
            }
            .admin-message-area {
                font-size: 0.85rem;
            }
            .admin-menu {
                flex-direction: column;
                gap: 5px;
            }
            .menu-item {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="admin-container">
        <h1>Administração - Gerenciamento de Cards</h1>
        
        <div class="form-group">
            <label for="adminSecretKey">Chave Secreta de Administração:</label>
            <input type="password" id="adminSecretKey" placeholder="Digite sua chave secreta">
        </div>

        <div class="admin-menu">
            <div class="menu-item active" data-target="generate-bulk-section">Gerar via IA</div>
            <div class="menu-item" data-target="upload-csv-section">Upload CSV</div>
            <div class="menu-item" data-target="update-all-section">Atualizar Todos</div>
            <div class="menu-item" data-target="update-single-section">Atualizar Individual</div> </div>

        <div id="generate-bulk-section" class="admin-section-content active">
            <h2 class="section-header">Gerar Cards em Massa via IA (Gemini)</h2>
            <p class="text-gray-600 text-center text-sm">Digite os nomes das linguagens, frameworks ou tecnologias, separados por vírgula. O Gemini gerará os dados de texto para cada um. As imagens serão placeholders e precisarão ser geradas separadamente na página de coleção.</p>
            
            <div class="form-group">
                <label for="languageNamesInput">Nomes (separados por vírgula):</label>
                <input type="text" id="languageNamesInput" placeholder="Python, Java, React, Node.js">
            </div>

            <button id="generateBulkButton" class="action-button generate">Gerar Cards via Gemini em Massa</button>
            <div id="adminMessageAreaGenerate" class="admin-message-area"></div>
        </div>

        <div id="upload-csv-section" class="admin-section-content">
            <h2 class="section-header">Upload de Linguagens via CSV</h2>
            <p class="text-gray-600 text-center text-sm">Cole o conteúdo CSV completo (incluindo o cabeçalho) da lista de linguagens. A coluna de nomes deve ser "ProgrammingLanguage".</p>
            
            <div class="form-group">
                <label for="csvDataInput">Conteúdo CSV:</label>
                <textarea id="csvDataInput" placeholder="ProgrammingLanguage,OtherColumn&#10;Python,Value1&#10;Java,Value2"></textarea>
            </div>

            <button id="uploadCsvButton" class="action-button csv-upload">Fazer Upload CSV e Gerar</button>
            <div id="adminMessageAreaCsvUpload" class="admin-message-area"></div>
        </div>

        <div id="update-all-section" class="admin-section-content">
            <h2 class="section-header">Atualizar Todos os Cards Existentes</h2>
            <p class="text-gray-600 text-center text-sm">Re-gera os dados e a imagem de *todos* os cards na sua coleção via IA. Isso pode levar um longo tempo e consumir muitos créditos da API de imagem.</p>
            
            <button id="updateAllCardsButtonAdmin" class="action-button refresh-all">Atualizar Todos Cards Agora</button>
            <div id="adminMessageAreaUpdateAll" class="admin-message-area"></div>
        </div>

        <div id="update-single-section" class="admin-section-content">
            <h2 class="section-header">Atualizar Card Individualmente</h2>
            <p class="text-gray-600 text-center text-sm">Busque um card existente pelo nome e decida se deseja re-gerar seus dados e/ou imagem via IA.</p>
            
            <div class="form-group">
                <label for="singleLanguageInput">Nome da Linguagem:</label>
                <input type="text" id="singleLanguageInput" placeholder="Python ou Java">
            </div>
            <button id="searchSingleCardButton" class="action-button search-single">Buscar Card</button>
            <div id="adminMessageAreaSingle" class="admin-message-area"></div>

            <div id="singleCardDisplayAdmin" class="single-card-display-admin">
                <p class="text-gray-500">Busque por uma linguagem para ver o card aqui.</p>
            </div>
        </div>
        
        <button id="backToHomeButton" class="back-to-home-button">Voltar à Página Inicial</button>
    </div>

    <script type="module">
        const API_BASE_URL = 'http://localhost:3000'; 

        // Importa a função getLanguageTheme do arquivo separado (necessário para renderizar o card)
        import { getLanguageTheme } from '/public/themes.js'; 

        // Elementos do Menu
        const menuItems = document.querySelectorAll('.admin-menu .menu-item');
        const adminSections = document.querySelectorAll('.admin-section-content');

        // Elementos para Geração em Massa via IA
        const languageNamesInput = document.getElementById('languageNamesInput');
        const generateBulkButton = document.getElementById('generateBulkButton');
        const adminMessageAreaGenerate = document.getElementById('adminMessageAreaGenerate');

        // Elementos para Upload CSV
        const csvDataInput = document.getElementById('csvDataInput');
        const uploadCsvButton = document.getElementById('uploadCsvButton');
        const adminMessageAreaCsvUpload = document.getElementById('adminMessageAreaCsvUpload');

        // Elementos para Atualizar Todos os Cards
        const updateAllCardsButtonAdmin = document.getElementById('updateAllCardsButtonAdmin');
        const adminMessageAreaUpdateAll = document.getElementById('adminMessageAreaUpdateAll');

        // NOVO: Elementos para Atualizar Card Individualmente
        const singleLanguageInput = document.getElementById('singleLanguageInput');
        const searchSingleCardButton = document.getElementById('searchSingleCardButton');
        const singleCardDisplayAdmin = document.getElementById('singleCardDisplayAdmin');
        const adminMessageAreaSingle = document.getElementById('adminMessageAreaSingle'); // Mensagens para essa seção


        // Elemento da Chave Secreta (compartilhado)
        const adminSecretKeyInput = document.getElementById('adminSecretKey');

        const backToHomeButton = document.getElementById('backToHomeButton');

        // Função para atualizar mensagens (agora específica para áreas diferentes)
        const updateMessage = (areaElement, message, type = 'info') => {
            areaElement.textContent = message;
            areaElement.className = 'admin-message-area ' + type;
        };

        // Lógica de controle do menu
        menuItems.forEach(item => {
            item.addEventListener('click', () => {
                const targetId = item.dataset.target;

                // Remove 'active' de todos os itens do menu e das seções de conteúdo
                menuItems.forEach(mi => mi.classList.remove('active'));
                adminSections.forEach(sec => sec.classList.remove('active'));

                // Adiciona 'active' ao item clicado e à seção de conteúdo correspondente
                item.classList.add('active');
                document.getElementById(targetId).classList.add('active');

                // Limpa a área de exibição do card individual ao mudar de seção
                if (targetId !== 'update-single-section') {
                    singleCardDisplayAdmin.innerHTML = '<p class="text-gray-500">Busque por uma linguagem para ver o card aqui.</p>';
                    updateMessage(adminMessageAreaSingle, ''); // Limpa mensagem da seção single
                    singleLanguageInput.value = ''; // Limpa o input
                }
            });
        });

        // Event Listener para Geração em Massa via IA (Gemini)
        generateBulkButton.addEventListener('click', async () => {
            const languageNames = languageNamesInput.value.trim();
            const adminKey = adminSecretKeyInput.value.trim();

            if (!languageNames) {
                updateMessage(adminMessageAreaGenerate, 'Por favor, digite os nomes das linguagens (separados por vírgula).', 'error');
                return;
            }

            if (!adminKey) {
                updateMessage(adminMessageAreaGenerate, 'Por favor, insira a chave secreta de administração.', 'error');
                return;
            }

            updateMessage(adminMessageAreaGenerate, 'Iniciando geração de cards via Gemini...', 'info');
            generateBulkButton.disabled = true;

            try {
                const response = await fetch(`${API_BASE_URL}/api/admin/generate-bulk`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminKey}` 
                    },
                    body: JSON.stringify({ languageNames: languageNames })
                });

                const result = await response.json();

                if (!response.ok) {
                    updateMessage(adminMessageAreaGenerate, `Erro de geração: ${result.error || 'Falha desconhecida'}`, 'error');
                    console.error('Erro de geração em massa:', result.error);
                } else {
                    let successCount = (typeof result.successful === 'number') ? result.successful : 0;
                    let failedCount = (typeof result.failed === 'number') ? result.failed : 0;
                    let successMessage = `Geração concluída: ${successCount} cards processados.`;
                    if (failedCount > 0) {
                        successMessage += ` ${failedCount} falharam. Verifique o console do servidor para mais detalhes.`;
                        updateMessage(adminMessageAreaGenerate, successMessage, 'warning'); 
                    } else {
                        updateMessage(adminMessageAreaGenerate, successMessage, 'success');
                    }
                }
            } catch (error) {
                updateMessage(adminMessageAreaGenerate, `Erro de rede ou servidor: ${error.message}. Verifique se o servidor Node.js está rodando.`, 'error');
                console.error('Erro na requisição de geração em massa:', error);
            } finally {
                generateBulkButton.disabled = false;
            }
        });

        // Event Listener para Upload CSV
        uploadCsvButton.addEventListener('click', async () => {
            const csvData = csvDataInput.value.trim();
            const adminKey = adminSecretKeyInput.value.trim();

            if (!csvData) {
                updateMessage(adminMessageAreaCsvUpload, 'Por favor, cole o conteúdo CSV.', 'error');
                return;
            }

            if (!adminKey) {
                updateMessage(adminMessageAreaCsvUpload, 'Por favor, insira a chave secreta de administração.', 'error');
                return;
            }

            updateMessage(adminMessageAreaCsvUpload, 'Enviando CSV para o servidor e iniciando geração...', 'info');
            uploadCsvButton.disabled = true;

            try {
                const response = await fetch(`${API_BASE_URL}/api/admin/upload-csv`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json', 
                        'Authorization': `Bearer ${adminKey}` 
                    },
                    body: JSON.stringify({ csvData: csvData }) 
                });

                const result = await response.json();

                if (!response.ok) {
                    updateMessage(adminMessageAreaCsvUpload, `Erro de upload CSV: ${result.error || 'Falha desconhecida'}`, 'error');
                    console.error('Erro de upload CSV:', result.error);
                } else {
                    let successCount = (typeof result.successful === 'number') ? result.successful : 0;
                    let failedCount = (typeof result.failed === 'number') ? result.failed : 0;
                    let successMessage = `Upload CSV concluído: ${successCount} cards adicionados/atualizados.`;
                    if (failedCount > 0) {
                        successMessage += ` ${failedCount} falharam. Verifique o console do servidor para mais detalhes.`;
                        updateMessage(adminMessageAreaCsvUpload, successMessage, 'warning'); 
                    } else {
                        updateMessage(adminMessageAreaCsvUpload, successMessage, 'success');
                    }
                }
            } catch (error) {
                updateMessage(adminMessageAreaCsvUpload, `Erro de rede ou servidor: ${error.message}. Verifique se o servidor Node.js está rodando.`, 'error');
                console.error('Erro na requisição de upload CSV:', error);
            } finally {
                uploadCsvButton.disabled = false;
            }
        });

        // Event Listener para Atualizar Todos os Cards (no Admin)
        updateAllCardsButtonAdmin.addEventListener('click', async () => {
            const adminKey = adminSecretKeyInput.value.trim();

            if (!adminKey) {
                updateMessage(adminMessageAreaUpdateAll, 'Por favor, insira a chave secreta de administração.', 'error');
                return;
            }

            if (!confirm("Tem certeza que deseja atualizar TODOS os cards da sua coleção? Isso pode levar vários minutos e consumir muitos créditos da API de imagem.")) {
                return;
            }

            updateMessage(adminMessageAreaUpdateAll, "Atualizando TODOS os cards... Isso pode demorar bastante!", "info");
            updateAllCardsButtonAdmin.disabled = true;

            try {
                const response = await fetch(`${API_BASE_URL}/api/cards/update`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminKey}` 
                    },
                    body: JSON.stringify({}) 
                });

                const result = await response.json();

                if (!response.ok) {
                    updateMessage(adminMessageAreaUpdateAll, `Erro ao atualizar todos os cards: ${result.error || 'Falha desconhecida'}`, "error");
                    console.error("Erro ao atualizar todos os cards:", result.error);
                } else {
                    let successCount = (typeof result.successful === 'number') ? result.successful : 0;
                    let failedCount = (typeof result.failed === 'number') ? result.failed : 0;
                    let successMessage = `Atualização em massa concluída: ${successCount} cards atualizados.`;
                    if (failedCount > 0) {
                        successMessage += ` ${failedCount} falharam. Verifique o console do servidor para detalhes.`;
                        updateMessage(adminMessageAreaUpdateAll, successMessage, "warning");
                    } else {
                        updateMessage(adminMessageAreaUpdateAll, successMessage, "success");
                    }
                }
            } catch (error) {
                updateMessage(adminMessageAreaUpdateAll, `Erro de rede ou servidor: ${error.message}. Verifique se o servidor Node.js está rodando.`, "error");
                console.error("Erro de rede ao atualizar todos os cards:", error);
            } finally {
                updateAllCardsButtonAdmin.disabled = false;
            }
        });

        // FUNÇÕES E EVENT LISTENERS PARA ATUALIZAR CARD INDIVIDUALMENTE
        // Função utilitária para adaptar o tamanho da fonte (copiada da collection.html)
        const fitTextToContainer = (element, maxFontSizePx, minFontSizePx, maxLines = 1) => {
            let currentFontSize = maxFontSizePx;
            element.style.fontSize = `${currentFontSize}px`;
            element.style.overflow = 'visible';
            element.style.whiteSpace = 'normal';

            while (currentFontSize > minFontSizePx) {
                let overflows = false;
                if (maxLines === 1) {
                    if (element.scrollWidth > element.clientWidth) {
                        overflows = true;
                    }
                } else {
                    if (element.scrollHeight > element.clientHeight) {
                        overflows = true;
                    }
                }
                if (overflows) {
                    currentFontSize -= 0.5;
                    element.style.fontSize = `${currentFontSize}px`;
                } else {
                    break;
                }
            }
            if (maxLines === 1) {
                element.style.overflow = 'hidden';
                element.style.whiteSpace = 'nowrap';
                element.style.textOverflow = 'ellipsis';
            } else {
                element.style.overflow = 'hidden';
                element.style.whiteSpace = 'normal';
            }
        };

        // Função para criar o elemento do card (copiada da collection.html e adaptada)
        const createCardElementAdmin = (cardData) => {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card-container'; // Reutiliza o estilo de card-container
            cardDiv.dataset.languageName = cardData.name; 

            // Adaptação para o tema
            const theme = getLanguageTheme(cardData.name); // getLanguageTheme precisa ser acessível
            for (const [prop, value] of Object.entries(theme)) {
                cardDiv.style.setProperty(prop, value);
            }

            let iconHtmlContent = '';
            if (cardData.iconUrl) {
                iconHtmlContent = `<img class="card-logo-svg" src="${API_BASE_URL}${cardData.iconUrl}" alt="${cardData.name} Icon">`;
            } else {
                const defaultSvgPath = '<path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm0 4c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4zm-4 10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"/>';
                iconHtmlContent = `<svg class="card-logo-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>${cardData.name}</title>${defaultSvgPath}</svg>`;
            }
            
            cardDiv.innerHTML = `
                <div class="card-header">
                    <div class="card-name-wrapper">
                        ${iconHtmlContent}
                        <div class="card-name" data-max-font="1.4" data-min-font="0.8">${cardData.name}</div>
                    </div>
                    <div class="card-type" data-max-font="0.8" data-min-font="0.6">${cardData.type}</div>
                </div>
                <div class="card-image-wrapper">
                    <img class="card-image" src="${cardData.imageUrl || API_BASE_URL + '/public/images/placeholder.png'}"
                        alt="Ilustração do ${cardData.name} como um Personagem Anime">
                </div>
                <div class="card-description" data-max-font="0.85" data-min-font="0.6" data-max-lines="4">
                    ${cardData.description}
                </div>
                <div class="card-stats">
                    <div class="stat-item">
                        <span class="stat-label">PWR/</span>
                        <span class="stat-value">${cardData.pwr !== undefined ? cardData.pwr : '--'}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">| VEL/</span>
                        <span class="stat-value">${cardData.vel !== undefined ? cardData.vel : '--'}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">| FLX/</span>
                        <span class="stat-value">${cardData.flx !== undefined ? cardData.flx : '--'}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">| COM/</span>
                        <span class="stat-value">${cardData.com !== undefined ? cardData.com : '--'}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">| CRV/</span>
                        <span class="stat-value">${cardData.crv !== undefined ? cardData.crv : '--'}</span>
                    </div>
                </div>
                <div class="card-footer">
                    <span>Ilustração: Amaro AI</span>
                    <button class="action-button update-single" data-language-name="${cardData.name}" title="Atualizar este card">Atualizar Card</button>
                </div>
            `;

            // Adiciona o event listener para o botão de atualização dentro do card
            const updateButton = cardDiv.querySelector('.action-button.update-single');
            if (updateButton) {
                updateButton.addEventListener('click', async () => {
                    const nameToUpdate = updateButton.dataset.languageName;
                    const adminKey = adminSecretKeyInput.value.trim(); // Pega a chave de admin

                    if (!adminKey) {
                        updateMessage(adminMessageAreaSingle, 'Por favor, insira a chave secreta de administração para atualizar o card.', 'error');
                        return;
                    }

                    if (confirm(`Tem certeza que deseja atualizar o card de "${nameToUpdate}"? Isso regerará seus dados e imagem via IA.`)) {
                        updateMessage(adminMessageAreaSingle, `Atualizando card para "${nameToUpdate}"... Isso pode levar um momento.`, "info");
                        updateButton.disabled = true;
                        searchSingleCardButton.disabled = true; // Desabilita busca enquanto atualiza
                        
                        try {
                            const response = await fetch(`${API_BASE_URL}/api/cards/update`, {
                                method: 'POST',
                                headers: { 
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${adminKey}` 
                                },
                                body: JSON.stringify({ languageName: nameToUpdate })
                            });

                            if (!response.ok) {
                                const errorData = await response.json();
                                throw new Error(errorData.error || `Erro ao atualizar card: ${response.status} ${response.statusText}`);
                            }

                            const result = await response.json();
                            updateMessage(adminMessageAreaSingle, `Card para "${nameToUpdate}" atualizado com sucesso!`, "success");
                            // Re-exibe o card atualizado se a busca foi bem-sucedida
                            await handleSearchSingleCard(); 

                        } catch (error) {
                            console.error(`Erro ao atualizar card "${nameToUpdate}":`, error);
                            updateMessage(adminMessageAreaSingle, `Erro ao atualizar card "${nameToUpdate}": ${error.message}`, "error");
                        } finally {
                            updateButton.disabled = false;
                            searchSingleCardButton.disabled = false;
                        }
                    }
                });
            }

            return cardDiv;
        };

        // Lógica de busca de card individual
        const handleSearchSingleCard = async () => {
            const languageName = singleLanguageInput.value.trim();
            const adminKey = adminSecretKeyInput.value.trim();

            if (!languageName) {
                updateMessage(adminMessageAreaSingle, 'Por favor, digite o nome de uma linguagem para buscar.', 'error');
                return;
            }
            if (!adminKey) {
                updateMessage(adminMessageAreaSingle, 'Por favor, insira a chave secreta de administração.', 'error');
                return;
            }

            updateMessage(adminMessageAreaSingle, `Buscando card para "${languageName}"...`, 'info');
            searchSingleCardButton.disabled = true;

            try {
                const response = await fetch(`${API_BASE_URL}/api/admin/cards/${encodeURIComponent(languageName)}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${adminKey}` 
                    }
                });

                const result = await response.json();

                if (!response.ok) {
                    singleCardDisplayAdmin.innerHTML = `<p class="text-gray-500">${result.message || 'Card não encontrado.'}</p>`;
                    updateMessage(adminMessageAreaSingle, `Card "${languageName}" não encontrado.`, 'warning');
                    console.error('Erro ao buscar card individual:', result.message || result.error);
                } else {
                    singleCardDisplayAdmin.innerHTML = ''; // Limpa a área
                    const cardElement = createCardElementAdmin(result); // Cria o card
                    singleCardDisplayAdmin.appendChild(cardElement); // Adiciona ao display

                    // Ajusta as fontes do card recém-criado
                    const remToPx = parseFloat(window.getComputedStyle(document.documentElement).fontSize);
                    const nameEl = cardElement.querySelector('.card-name');
                    const typeEl = cardElement.querySelector('.card-type');
                    const descriptionEl = cardElement.querySelector('.card-description');

                    if (nameEl) fitTextToContainer(nameEl, parseFloat(nameEl.dataset.maxFont) * remToPx, parseFloat(nameEl.dataset.minFont) * remToPx, 1);
                    if (typeEl) fitTextToContainer(typeEl, parseFloat(typeEl.dataset.maxFont) * remToPx, parseFloat(typeEl.dataset.minFont) * remToPx, 1);
                    if (descriptionEl) fitTextToContainer(descriptionEl, parseFloat(descriptionEl.dataset.maxFont) * remToPx, parseFloat(descriptionEl.dataset.minFont) * remToPx, parseInt(descriptionEl.dataset.maxLines, 10));

                    updateMessage(adminMessageAreaSingle, `Card para "${languageName}" encontrado.`, 'success');
                }
            } catch (error) {
                updateMessage(adminMessageAreaSingle, `Erro de rede ou servidor ao buscar card: ${error.message}.`, 'error');
                console.error('Erro na requisição de busca de card individual:', error);
                singleCardDisplayAdmin.innerHTML = '<p class="text-red-500">Erro ao carregar card.</p>';
            } finally {
                searchSingleCardButton.disabled = false;
            }
        };

        searchSingleCardButton.addEventListener('click', handleSearchSingleCard);
        singleLanguageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSearchSingleCard();
            }
        });


        backToHomeButton.addEventListener('click', () => {
            window.location.href = '/index.html';
        });
    </script>
</body>
</html>